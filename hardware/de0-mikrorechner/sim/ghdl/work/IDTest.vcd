$date
  Fri Jan 16 18:16:18 2026
$end
$version
  GHDL v0
$end
$timescale
  1 fs
$end
$scope module standard $end
$upscope $end
$scope module std_logic_1164 $end
$upscope $end
$scope module numeric_std $end
$upscope $end
$scope module alu_opcode $end
$upscope $end
$scope module opcodes $end
$upscope $end
$scope module funct_codes $end
$upscope $end
$scope module idtest $end
$var reg 32 ! pc_in_in[31:0] $end
$var reg 32 " instruction_in[31:0] $end
$var reg 32 # write_data_in[31:0] $end
$var reg 1 $ clk_in $end
$var reg 1 % reg_we_in $end
$var reg 5 & write_reg_in[4:0] $end
$var reg 32 ' pc_out_out[31:0] $end
$var reg 32 ( alu_val_out[31:0] $end
$var reg 32 ) reg_val_out[31:0] $end
$var reg 32 * imm_out[31:0] $end
$var reg 5 + alu_op_out[4:0] $end
$var reg 5 , rt_out[4:0] $end
$var reg 5 - rd_out[4:0] $end
$var reg 1 . reg_dest_out $end
$var reg 1 / reg_write_ex_out $end
$var reg 1 0 alu_src_out $end
$var reg 1 1 pc_src_out $end
$var reg 1 2 mem_write_out $end
$var reg 1 3 mem_to_reg_ex_out $end
$var reg 1 4 jr_out $end
$var reg 1 5 jar_out $end
$scope module idi $end
$var reg 32 6 pc_in[31:0] $end
$var reg 32 7 instruction[31:0] $end
$var reg 32 8 write_data[31:0] $end
$var reg 1 9 clk $end
$var reg 1 : reg_we $end
$var reg 5 ; write_reg[4:0] $end
$var reg 32 < pc_out[31:0] $end
$var reg 32 = alu_val[31:0] $end
$var reg 32 > reg_val[31:0] $end
$var reg 32 ? imm[31:0] $end
$var reg 5 @ alu_op[4:0] $end
$var reg 5 A rt[4:0] $end
$var reg 5 B rd[4:0] $end
$var reg 1 C reg_dest $end
$var reg 1 D reg_write_ex $end
$var reg 1 E alu_src $end
$var reg 1 F pc_src $end
$var reg 1 G mem_write $end
$var reg 1 H mem_to_reg_ex $end
$var reg 1 I jr $end
$var reg 1 J jar $end
$var reg 5 K sel_alu_val[4:0] $end
$var reg 5 L sel_reg_val[4:0] $end
$var reg 5 M rt_sig[4:0] $end
$var reg 32 N alu_val_sig[31:0] $end
$var reg 32 O reg_val_sig[31:0] $end
$scope module registerbanki $end
$var reg 1 P clk $end
$var reg 32 Q din[31:0] $end
$var reg 32 R douta[31:0] $end
$var reg 32 S doutb[31:0] $end
$var reg 5 T sela[4:0] $end
$var reg 5 U selb[4:0] $end
$var reg 5 V seld[4:0] $end
$var reg 1 W we $end
$comment registers is not handled $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
b00000000000000000000000000000001 !
b00000000000000000000000000000001 "
b00000000000000000000000000000001 #
0$
1%
b00000 &
bUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU '
bUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU (
bUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU )
bUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU *
bUUUUU +
bUUUUU ,
bUUUUU -
U.
U/
U0
U1
U2
U3
U4
U5
b00000000000000000000000000000001 6
b00000000000000000000000000000001 7
b00000000000000000000000000000001 8
09
1:
b00000 ;
bUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU <
bUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU =
bUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU >
bUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU ?
bUUUUU @
bUUUUU A
bUUUUU B
UC
UD
UE
UF
UG
UH
UI
UJ
b00000 K
b00000 L
b00000 M
b00000000000000000000000000000000 N
b00000000000000000000000000000000 O
0P
b00000000000000000000000000000001 Q
b00000000000000000000000000000000 R
b00000000000000000000000000000000 S
b00000 T
b00000 U
b00000 V
1W
#10000000
1$
b00000000000000000000000000000001 '
b00000000000000000000000000000000 (
b00000000000000000000000000000000 )
b00000000000000000000000000000001 *
b00010 +
b00000 ,
b00000 -
1.
1/
00
01
02
03
04
05
19
b00000000000000000000000000000001 <
b00000000000000000000000000000000 =
b00000000000000000000000000000000 >
b00000000000000000000000000000001 ?
b00010 @
b00000 A
b00000 B
1C
1D
0E
0F
0G
0H
0I
0J
1P
#20000000
#30000000
